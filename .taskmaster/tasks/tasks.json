{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup CMake Build System",
        "description": "Create the initial CMake configuration for the KadeDB project with proper directory structure and build presets.",
        "details": "Create the following structure:\n- Root CMakeLists.txt with project definition\n- cpp/CMakeLists.txt for C++ core\n- cpp/src/ for implementation files\n- cpp/include/kadedb/ for public headers\n- bindings/c/ for C ABI headers\n- lite/ for KadeDB-Lite implementation\n\nImplement CMake presets for different build configurations (Debug, Release). Setup proper version numbering, install targets, and export configuration to enable downstream projects to use find_package(KadeDB). Include RocksDB as a dependency for the Lite implementation.",
        "testStrategy": "Verify build system by running CMake configuration and build process on different platforms. Ensure all targets build successfully and that downstream projects can consume the library via find_package(KadeDB).",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Root CMakeLists.txt and Project Definition",
            "description": "Set up the main CMakeLists.txt file at the project root with proper project definition, minimum CMake version, C++ standard settings, and compiler options.",
            "dependencies": [],
            "details": "Create the root CMakeLists.txt with:\n- Set minimum CMake version (3.14 or newer)\n- Define project name, version, description, and languages (C, CXX)\n- Set C++ standard (C++17 or newer)\n- Configure compiler warnings and options\n- Define build type options if not using presets\n- Add global include directories\n- Setup output directories for binaries\n- Include subdirectories for components",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Directory Structure and Component CMakeLists",
            "description": "Create the directory structure and component-specific CMakeLists.txt files for the core library, C bindings, and KadeDB-Lite implementation.",
            "dependencies": [],
            "details": "1. Create directories:\n   - cpp/src/ for implementation files\n   - cpp/include/kadedb/ for public headers\n   - bindings/c/ for C ABI headers\n   - lite/ for KadeDB-Lite implementation\n2. Create cpp/CMakeLists.txt for the core library\n3. Create bindings/c/CMakeLists.txt for C bindings\n4. Create lite/CMakeLists.txt for KadeDB-Lite\n5. Configure each component as a separate target with appropriate properties",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Configure CMake Presets for Build Configurations",
            "description": "Create CMakePresets.json file with presets for Debug and Release builds, as well as cross-platform configurations.",
            "dependencies": [],
            "details": "1. Create CMakePresets.json with:\n   - Debug preset with debug symbols, no optimization\n   - Release preset with optimizations\n   - RelWithDebInfo preset\n   - Platform-specific presets for Windows, Linux, macOS\n   - Configure generator presets (Ninja, Visual Studio, etc.)\n2. Add test presets for CTest integration\n3. Document usage of presets in README.md",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Version Numbering and Configuration",
            "description": "Set up version numbering system and configure version information to be accessible at runtime.",
            "dependencies": [],
            "details": "1. Define version variables in root CMakeLists.txt (MAJOR, MINOR, PATCH)\n2. Create a version.h.in template file\n3. Use configure_file() to generate version.h with CMake variables\n4. Implement a GetVersion() function that returns version information\n5. Setup SOVERSION for shared libraries\n6. Configure package version for find_package compatibility",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Setup Install Targets and Export Configuration",
            "description": "Configure installation targets and export configuration to enable downstream projects to use find_package(KadeDB).",
            "dependencies": [],
            "details": "1. Define install targets for libraries, headers, and binaries\n2. Create and install KadeDBConfig.cmake and KadeDBConfigVersion.cmake\n3. Set up export targets with EXPORT keyword\n4. Configure component-based installation\n5. Add install rules for documentation and examples\n6. Test the installation process and find_package functionality",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Integrate RocksDB Dependency for KadeDB-Lite",
            "description": "Set up third-party dependency management for RocksDB and integrate it with the KadeDB-Lite implementation.",
            "dependencies": [],
            "details": "1. Add options for using system RocksDB vs. building from source\n2. Implement find_package(RocksDB) with fallback to FetchContent\n3. Configure RocksDB build options if building from source\n4. Set up proper linking of RocksDB to KadeDB-Lite target\n5. Handle platform-specific configurations for RocksDB\n6. Document RocksDB dependency requirements",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create CI Build and Test Verification Scripts",
            "description": "Develop CI configuration scripts for automated building and testing across different platforms and configurations.",
            "dependencies": [],
            "details": "1. Create GitHub Actions workflow files for CI/CD\n2. Configure matrix builds for different platforms (Windows, Linux, macOS)\n3. Set up build jobs for different configurations (Debug, Release)\n4. Implement test execution in CI pipeline\n5. Add caching for dependencies and build artifacts\n6. Configure code coverage reporting\n7. Add status badges to README.md",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Data Model Primitives",
        "description": "Define the core data model primitives that will be used throughout the KadeDB system.",
        "details": "Create C++ classes for fundamental data types:\n- Value class hierarchy (Integer, Float, String, Boolean, etc.)\n- Schema definition (Column, Table, Document)\n- Result set representations\n\nImplement serialization/deserialization for these primitives. Ensure proper memory management and copy semantics. Design with FFI compatibility in mind to simplify C binding creation later.\n\nExample:\n```cpp\nnamespace kadedb {\n  class Value {\n  public:\n    virtual ~Value() = default;\n    virtual ValueType type() const = 0;\n    virtual std::string toString() const = 0;\n  };\n  \n  class IntegerValue : public Value {\n  private:\n    int64_t value_;\n  public:\n    explicit IntegerValue(int64_t value) : value_(value) {}\n    ValueType type() const override { return ValueType::Integer; }\n    int64_t value() const { return value_; }\n    std::string toString() const override { return std::to_string(value_); }\n  };\n  // Other value types...\n}\n```",
        "testStrategy": "Create comprehensive unit tests for each primitive type, testing construction, conversion, comparison, and serialization/deserialization. Test edge cases like empty values, maximum/minimum values, and invalid inputs.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Value Class Hierarchy",
            "description": "Create the core Value class hierarchy for representing different data types in KadeDB.",
            "dependencies": [],
            "details": "Implement the following classes:\n- Abstract `Value` base class with virtual methods for type identification, conversion, and comparison\n- Concrete value types: `IntegerValue`, `FloatValue`, `StringValue`, `BooleanValue`, `NullValue`\n- Include appropriate constructors, accessors, and type conversion methods\n- Implement comparison operators and equality checking\n- Add a ValueType enum to identify different value types\n- Create a ValueFactory for creating values from different input types",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Schema Definition Classes",
            "description": "Create classes for defining database schemas including columns, tables, and documents.",
            "dependencies": [],
            "details": "Implement the following classes:\n- `Column` class with name, type, constraints (nullable, unique, etc.)\n- `TableSchema` class containing column definitions and primary key information\n- `DocumentSchema` class for flexible document structures\n- `Row` class for representing a row of data in a table\n- `SchemaValidator` for validating data against schemas\n- Add methods for schema modification and validation",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Result Set Representation",
            "description": "Create classes for representing query results in a consistent format.",
            "dependencies": [],
            "details": "Implement the following classes:\n- `ResultSet` class to hold query results\n- `ResultRow` class for individual rows in a result set\n- Methods for iterating through results\n- Support for metadata about the results (column names, types)\n- Conversion utilities to transform results to different formats\n- Pagination support for large result sets\n- Error handling for invalid access patterns",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Serialization/Deserialization",
            "description": "Create serialization and deserialization mechanisms for all data model primitives.",
            "dependencies": [],
            "details": "Implement the following:\n- Binary serialization format for all Value types\n- JSON serialization/deserialization for all data model classes\n- Schema serialization for storage and transmission\n- Version tagging for forward/backward compatibility\n- Optimized serialization for common data types\n- Error handling for corrupted or incompatible data\n- Benchmark different serialization approaches for performance",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Memory Management and Copy Semantics",
            "description": "Ensure proper memory management and define appropriate copy/move semantics for all data model classes.",
            "dependencies": [],
            "details": "Implement the following:\n- Define move and copy constructors/assignment operators for all classes\n- Use smart pointers (std::shared_ptr, std::unique_ptr) for ownership management\n- Implement proper destructors to prevent memory leaks\n- Add memory pooling for frequently created small objects\n- Create deep and shallow copy mechanisms where appropriate\n- Implement reference counting for large objects\n- Add debug tools for tracking memory usage and detecting leaks",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Design and Document FFI Compatibility",
            "description": "Design the data model with FFI compatibility in mind and document the approach for C bindings.",
            "dependencies": [],
            "details": "Implement the following:\n- Create C-compatible struct representations of core data types\n- Implement conversion functions between C++ and C representations\n- Document memory ownership rules for FFI boundaries\n- Create example C header files showing the intended FFI interface\n- Design error handling that works across language boundaries\n- Implement opaque pointer patterns for C interfaces\n- Write comprehensive documentation on how to use the data model from C code",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Storage API",
        "description": "Create the storage API interfaces for both relational and document data models.",
        "details": "Define abstract interfaces for storage operations:\n\n1. Relational Storage API:\n```cpp\nclass RelationalStorage {\npublic:\n  virtual ~RelationalStorage() = default;\n  virtual Status createTable(const TableSchema& schema) = 0;\n  virtual Status insertRow(const std::string& table, const Row& row) = 0;\n  virtual ResultSet select(const std::string& table, const std::vector<std::string>& columns, \n                          const std::optional<Predicate>& where = std::nullopt) = 0;\n};\n```\n\n2. Document Storage API:\n```cpp\nclass DocumentStorage {\npublic:\n  virtual ~DocumentStorage() = default;\n  virtual Status put(const std::string& collection, const std::string& key, const Document& doc) = 0;\n  virtual Result<Document> get(const std::string& collection, const std::string& key) = 0;\n};\n```\n\nImplement an in-memory version of these interfaces for testing and development. Design with extensibility in mind to support different backend implementations later.",
        "testStrategy": "Create unit tests for the storage APIs using the in-memory implementation. Test table creation, data insertion, and basic queries. Verify error handling for invalid operations (e.g., creating a table that already exists, inserting data with wrong schema).",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Relational Storage API Interface",
            "description": "Finalize the RelationalStorage interface with all required methods, error handling, and documentation.",
            "dependencies": [],
            "details": "1. Review and refine the existing RelationalStorage interface\n2. Add detailed documentation for each method\n3. Define appropriate error codes and status returns\n4. Add any missing methods needed for MVP functionality\n5. Define the TableSchema, Row, ResultSet, and Predicate classes/structs\n6. Ensure the interface is extensible for future backend implementations",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Define Document Storage API Interface",
            "description": "Finalize the DocumentStorage interface with all required methods, error handling, and documentation.",
            "dependencies": [],
            "details": "1. Review and refine the existing DocumentStorage interface\n2. Add detailed documentation for each method\n3. Define appropriate error codes and status returns\n4. Add any missing methods needed for MVP functionality (e.g., query, delete)\n5. Define the Document class/struct and its serialization methods\n6. Ensure the interface is extensible for future backend implementations",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement In-Memory Relational Storage",
            "description": "Create an in-memory implementation of the RelationalStorage interface for testing and development.",
            "dependencies": [],
            "details": "1. Create a MemoryRelationalStorage class that implements RelationalStorage\n2. Implement internal data structures to store tables and rows\n3. Implement createTable() with validation for duplicate tables\n4. Implement insertRow() with schema validation\n5. Implement select() with filtering based on predicates\n6. Add proper error handling for all operations\n7. Optimize for development and testing use cases",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement In-Memory Document Storage",
            "description": "Create an in-memory implementation of the DocumentStorage interface for testing and development.",
            "dependencies": [],
            "details": "1. Create a MemoryDocumentStorage class that implements DocumentStorage\n2. Implement internal data structures to store collections and documents\n3. Implement put() with validation\n4. Implement get() with proper error handling for missing documents\n5. Add any additional methods defined in the interface\n6. Optimize for development and testing use cases",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create Unit Tests for Storage APIs",
            "description": "Develop comprehensive unit tests for both storage APIs and their in-memory implementations.",
            "dependencies": [],
            "details": "1. Create test fixtures for both storage implementations\n2. Test table/collection creation with valid and invalid schemas\n3. Test data insertion with valid and invalid data\n4. Test data retrieval with various query patterns\n5. Test error handling for all edge cases (e.g., duplicate tables, missing data)\n6. Test concurrent operations if applicable\n7. Measure and document test coverage\n8. Create integration tests that use both APIs together if needed",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement KadeQL Parser Subset",
        "description": "Create a minimal hand-rolled parser for the KadeQL subset required for the MVP.",
        "details": "Implement a simple recursive descent parser for basic KadeQL statements:\n\n1. SELECT statement with basic WHERE clauses\n2. INSERT statement for adding data\n\nFocus on the minimal subset needed for the MVP. Parse queries into an abstract syntax tree (AST) that can be executed by the query engine.\n\nExample parser implementation:\n```cpp\nclass KadeQLParser {\npublic:\n  std::unique_ptr<Statement> parse(const std::string& query) {\n    Tokenizer tokenizer(query);\n    return parseStatement(tokenizer);\n  }\n\nprivate:\n  std::unique_ptr<Statement> parseStatement(Tokenizer& tokenizer) {\n    Token token = tokenizer.peek();\n    if (token.type == TokenType::SELECT) {\n      return parseSelectStatement(tokenizer);\n    } else if (token.type == TokenType::INSERT) {\n      return parseInsertStatement(tokenizer);\n    }\n    throw ParseError(\"Unexpected token: \" + token.value);\n  }\n  \n  // Implementation of parseSelectStatement and parseInsertStatement\n};\n```\n\nAvoid using external parser generators like ANTLR for the MVP as mentioned in the risks section.",
        "testStrategy": "Create unit tests with various KadeQL queries, verifying that they parse correctly into the expected AST structure. Include negative tests with invalid syntax to ensure proper error reporting.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Tokenizer/Lexer for KadeQL",
            "description": "Create a lexical analyzer that converts KadeQL query strings into tokens for the parser to process.",
            "dependencies": [],
            "details": "Implement a Tokenizer class that:\n1. Breaks input queries into tokens (keywords, identifiers, operators, literals)\n2. Handles basic SQL keywords (SELECT, FROM, WHERE, INSERT, INTO, VALUES)\n3. Recognizes operators (=, <, >, <=, >=, !=) and delimiters\n4. Supports string and numeric literals\n5. Includes position tracking for error reporting\n\nExample implementation:\n```cpp\nenum class TokenType {\n  SELECT, FROM, WHERE, INSERT, INTO, VALUES,\n  IDENTIFIER, STRING_LITERAL, NUMBER_LITERAL,\n  EQUALS, LESS_THAN, GREATER_THAN, // etc.\n  COMMA, SEMICOLON, LPAREN, RPAREN,\n  END_OF_INPUT\n};\n\nstruct Token {\n  TokenType type;\n  std::string value;\n  size_t line;\n  size_t column;\n};\n\nclass Tokenizer {\npublic:\n  explicit Tokenizer(const std::string& input);\n  Token next();\n  Token peek();\n  bool hasMore();\nprivate:\n  // Implementation details\n};\n```",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement AST Structure for KadeQL",
            "description": "Design and implement the Abstract Syntax Tree (AST) classes to represent parsed KadeQL statements.",
            "dependencies": [],
            "details": "Create a hierarchy of classes to represent the parsed query structure:\n\n1. Base Statement class with common functionality\n2. SelectStatement class with fields for columns, table name, and WHERE conditions\n3. InsertStatement class with table name and values to insert\n4. Expression classes for WHERE clause conditions\n5. Predicate classes for comparison operations\n\nExample implementation:\n```cpp\nclass Statement {\npublic:\n  virtual ~Statement() = default;\n  virtual StatementType type() const = 0;\n};\n\nclass SelectStatement : public Statement {\npublic:\n  StatementType type() const override { return StatementType::SELECT; }\n  std::vector<std::string> columns;\n  std::string table;\n  std::unique_ptr<Expression> whereClause;\n};\n\nclass InsertStatement : public Statement {\npublic:\n  StatementType type() const override { return StatementType::INSERT; }\n  std::string table;\n  std::vector<std::string> columns;\n  std::vector<std::vector<std::unique_ptr<Expression>>> values;\n};\n```",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement SELECT Statement Parser",
            "description": "Create a recursive descent parser for SELECT statements with basic WHERE clauses.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Implement the SELECT statement parser that:\n\n1. Parses the SELECT keyword followed by column names or * for all columns\n2. Handles the FROM clause with table name\n3. Processes optional WHERE clauses with comparison operators\n4. Builds the appropriate SelectStatement AST node\n5. Provides clear error messages for syntax errors\n\nExample implementation:\n```cpp\nstd::unique_ptr<SelectStatement> parseSelectStatement(Tokenizer& tokenizer) {\n  // Consume SELECT keyword\n  tokenizer.consume(TokenType::SELECT);\n  \n  auto stmt = std::make_unique<SelectStatement>();\n  \n  // Parse column list\n  if (tokenizer.peek().type == TokenType::ASTERISK) {\n    tokenizer.consume(TokenType::ASTERISK);\n    stmt->columns.push_back(\"*\");\n  } else {\n    // Parse comma-separated column names\n    do {\n      Token columnToken = tokenizer.consume(TokenType::IDENTIFIER);\n      stmt->columns.push_back(columnToken.value);\n      \n      if (tokenizer.peek().type != TokenType::COMMA) {\n        break;\n      }\n      tokenizer.consume(TokenType::COMMA);\n    } while (true);\n  }\n  \n  // Parse FROM clause\n  tokenizer.consume(TokenType::FROM);\n  Token tableToken = tokenizer.consume(TokenType::IDENTIFIER);\n  stmt->table = tableToken.value;\n  \n  // Parse optional WHERE clause\n  if (tokenizer.peek().type == TokenType::WHERE) {\n    tokenizer.consume(TokenType::WHERE);\n    stmt->whereClause = parseExpression(tokenizer);\n  }\n  \n  return stmt;\n}\n```",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement INSERT Statement Parser and Error Handling",
            "description": "Create a parser for INSERT statements and implement robust error handling throughout the parser.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Implement the INSERT statement parser and error handling that:\n\n1. Parses the INSERT INTO keyword followed by table name\n2. Handles optional column list in parentheses\n3. Processes VALUES keyword and the values to insert\n4. Builds the appropriate InsertStatement AST node\n5. Implements a comprehensive error handling system with:\n   - Descriptive error messages including position information\n   - Recovery mechanisms where appropriate\n   - Validation of semantic constraints\n\nExample implementation:\n```cpp\nstd::unique_ptr<InsertStatement> parseInsertStatement(Tokenizer& tokenizer) {\n  // Consume INSERT INTO keywords\n  tokenizer.consume(TokenType::INSERT);\n  tokenizer.consume(TokenType::INTO);\n  \n  auto stmt = std::make_unique<InsertStatement>();\n  \n  // Parse table name\n  Token tableToken = tokenizer.consume(TokenType::IDENTIFIER);\n  stmt->table = tableToken.value;\n  \n  // Parse optional column list\n  if (tokenizer.peek().type == TokenType::LPAREN) {\n    tokenizer.consume(TokenType::LPAREN);\n    \n    do {\n      Token columnToken = tokenizer.consume(TokenType::IDENTIFIER);\n      stmt->columns.push_back(columnToken.value);\n      \n      if (tokenizer.peek().type != TokenType::COMMA) {\n        break;\n      }\n      tokenizer.consume(TokenType::COMMA);\n    } while (true);\n    \n    tokenizer.consume(TokenType::RPAREN);\n  }\n  \n  // Parse VALUES keyword and values\n  tokenizer.consume(TokenType::VALUES);\n  \n  do {\n    tokenizer.consume(TokenType::LPAREN);\n    std::vector<std::unique_ptr<Expression>> rowValues;\n    \n    do {\n      rowValues.push_back(parseExpression(tokenizer));\n      \n      if (tokenizer.peek().type != TokenType::COMMA) {\n        break;\n      }\n      tokenizer.consume(TokenType::COMMA);\n    } while (true);\n    \n    tokenizer.consume(TokenType::RPAREN);\n    stmt->values.push_back(std::move(rowValues));\n    \n    if (tokenizer.peek().type != TokenType::COMMA) {\n      break;\n    }\n    tokenizer.consume(TokenType::COMMA);\n  } while (true);\n  \n  return stmt;\n}\n\nclass ParseError : public std::runtime_error {\npublic:\n  ParseError(const std::string& message, size_t line, size_t column)\n    : std::runtime_error(formatMessage(message, line, column)),\n      line_(line), column_(column) {}\n  \n  size_t line() const { return line_; }\n  size_t column() const { return column_; }\n  \nprivate:\n  size_t line_;\n  size_t column_;\n  \n  static std::string formatMessage(const std::string& message, size_t line, size_t column) {\n    return \"Parse error at line \" + std::to_string(line) + \n           \", column \" + std::to_string(column) + \": \" + message;\n  }\n};\n```",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Query Execution Engine",
        "description": "Create a query execution engine that can execute the parsed KadeQL statements against the storage layer.",
        "details": "Implement a query executor that takes parsed statements and executes them against the storage layer:\n\n```cpp\nclass QueryExecutor {\npublic:\n  explicit QueryExecutor(Storage& storage) : storage_(storage) {}\n  \n  Result<ResultSet> execute(const Statement& statement) {\n    switch (statement.type()) {\n      case StatementType::SELECT:\n        return executeSelect(static_cast<const SelectStatement&>(statement));\n      case StatementType::INSERT:\n        return executeInsert(static_cast<const InsertStatement&>(statement));\n      default:\n        return Error(\"Unsupported statement type\");\n    }\n  }\n\nprivate:\n  Storage& storage_;\n  \n  Result<ResultSet> executeSelect(const SelectStatement& select);\n  Result<ResultSet> executeInsert(const InsertStatement& insert);\n};\n```\n\nImplement basic query optimization for simple predicates. Focus on correctness rather than performance for the MVP.",
        "testStrategy": "Create integration tests that combine the parser and executor to run queries end-to-end. Verify that queries produce the expected results when executed against test data in the storage layer.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement QueryExecutor Interface and Core",
            "description": "Create the QueryExecutor class with the core execution framework that routes statements to appropriate handlers.",
            "dependencies": [],
            "details": "Implement the QueryExecutor class with constructor, execute() method, and the basic routing logic for different statement types. Include proper error handling and result type definitions. Set up the class structure with private methods for different statement types. Ensure the interface is clean and extensible for future statement types.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement SELECT Statement Execution",
            "description": "Develop the executeSelect() method to process SELECT statements against the storage layer.",
            "dependencies": [
              "5.1"
            ],
            "details": "Implement the executeSelect() method that translates a SelectStatement into storage API calls. Handle column projection, table identification, and WHERE clause translation. Create a ResultSet structure to hold query results. Implement proper error handling for cases like non-existent tables or columns. Test with various SELECT statement patterns including simple selects and those with WHERE clauses.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement INSERT Statement Execution",
            "description": "Develop the executeInsert() method to process INSERT statements against the storage layer.",
            "dependencies": [
              "5.1"
            ],
            "details": "Implement the executeInsert() method that translates an InsertStatement into storage API calls. Handle value validation against table schema, proper error reporting for schema mismatches, and successful insertion confirmation. Ensure proper type conversion between the query representation and storage layer requirements. Test with various INSERT patterns including single and multi-value inserts.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Basic Query Optimization",
            "description": "Add simple query optimization for basic predicates to improve execution efficiency.",
            "dependencies": [
              "5.2",
              "5.3"
            ],
            "details": "Implement a basic query optimizer that can reorder operations for efficiency. Focus on predicate pushdown to minimize data scanning. Optimize simple WHERE clauses by leveraging storage layer filtering capabilities. Implement predicate simplification for common patterns. Document optimization strategies used. Remember to prioritize correctness over performance for the MVP.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create Integration and End-to-End Tests",
            "description": "Develop comprehensive tests that verify the query executor works correctly with the parser and storage components.",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "Create integration tests that combine the parser, executor, and storage components. Develop end-to-end test cases covering SELECT and INSERT operations with various complexity levels. Test error handling and edge cases across the entire execution path. Verify result correctness against expected outputs. Include performance benchmarks for basic operations to establish baselines for future optimization.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Create C ABI Interface",
        "description": "Design and implement a stable C ABI for interfacing with the KadeDB core.",
        "details": "Create C headers in `bindings/c/` with the following components:\n\n1. Version information and initialization functions\n2. Constructor/destructor functions for core objects\n3. Simple CRUD operations\n\nExample C ABI:\n```c\n// kadedb.h\n#ifndef KADEDB_H\n#define KADEDB_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Opaque types\ntypedef struct KadeDB_Storage KadeDB_Storage;\ntypedef struct KadeDB_ResultSet KadeDB_ResultSet;\n\n// Version info\nconst char* KadeDB_GetVersion();\n\n// Storage operations\nKadeDB_Storage* KadeDB_CreateStorage();\nvoid KadeDB_DestroyStorage(KadeDB_Storage* storage);\n\n// CRUD operations\nint KadeDB_CreateTable(KadeDB_Storage* storage, const char* schema);\nint KadeDB_InsertRow(KadeDB_Storage* storage, const char* table, const char* data);\nKadeDB_ResultSet* KadeDB_ExecuteQuery(KadeDB_Storage* storage, const char* query);\n\n// ResultSet operations\nint KadeDB_ResultSet_NextRow(KadeDB_ResultSet* rs);\nconst char* KadeDB_ResultSet_GetString(KadeDB_ResultSet* rs, int column);\nvoid KadeDB_DestroyResultSet(KadeDB_ResultSet* rs);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // KADEDB_H\n```\n\nImplement the C++ side of these bindings that map between the C ABI and the C++ implementation.",
        "testStrategy": "Create C test programs that use the C ABI to verify it works correctly. Test memory management to ensure no leaks. Verify that all operations exposed through the C ABI work as expected.",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design C Header for Versioning and Initialization",
            "description": "Create the C header file structure with version information and initialization functions",
            "dependencies": [],
            "details": "Create the initial kadedb.h header file with:\n- Header guards and extern \"C\" block\n- Version information functions (KadeDB_GetVersion, KadeDB_GetMajorVersion, etc.)\n- Library initialization/cleanup functions if needed\n- Error handling constants and functions\n- Basic type definitions and forward declarations\n\nEnsure the header is properly documented with comments explaining usage.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Opaque Types and Memory Management",
            "description": "Define opaque type structures and their memory management functions",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement:\n- Opaque type definitions for KadeDB_Storage, KadeDB_ResultSet, and other necessary structures\n- Constructor functions (KadeDB_CreateStorage, etc.)\n- Destructor functions (KadeDB_DestroyStorage, etc.)\n- Reference counting or other memory management mechanisms if needed\n- Error state handling for these objects",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create CRUD Operation Bindings",
            "description": "Implement the C functions for basic CRUD operations",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Implement C functions for:\n- Table creation (KadeDB_CreateTable)\n- Data insertion (KadeDB_InsertRow)\n- Data retrieval (KadeDB_ExecuteQuery)\n- Data update operations\n- Data deletion operations\n- Schema manipulation functions\n\nEnsure proper error handling and memory safety.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Develop Result Set Access and Iteration",
            "description": "Implement functions for accessing and iterating through query results",
            "dependencies": [
              "6.2",
              "6.3"
            ],
            "details": "Create functions for:\n- Result set navigation (KadeDB_ResultSet_NextRow, KadeDB_ResultSet_Reset)\n- Data access by type (KadeDB_ResultSet_GetString, KadeDB_ResultSet_GetInt, etc.)\n- Column information retrieval (name, type, index)\n- Error state checking\n- Result set metadata access\n\nEnsure proper memory management and type safety.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement C++ Glue Code",
            "description": "Create the C++ implementation that bridges between the C ABI and the C++ core",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Implement the C++ side of the bindings in bindings/c/src/:\n- Create wrapper classes that implement the opaque C types\n- Implement all C API functions to call the corresponding C++ core functions\n- Handle memory management and object lifetime\n- Implement proper error translation between C++ exceptions and C error codes\n- Ensure thread safety where appropriate",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create C Test Suite",
            "description": "Develop a comprehensive test suite for the C ABI",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4",
              "6.5"
            ],
            "details": "Create tests in bindings/c/tests/ that:\n- Verify all API functions work correctly\n- Test error handling and edge cases\n- Validate memory safety (no leaks or double-frees)\n- Test thread safety if applicable\n- Include examples of typical usage patterns\n- Verify compatibility with C applications\n\nIntegrate these tests with the CMake build system.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement KadeDB-Lite RocksDB Backend",
        "description": "Create the KadeDB-Lite implementation using RocksDB as the storage backend.",
        "details": "Implement the KadeDB-Lite client in the `lite/` directory:\n\n1. Use RocksDB C API for storage operations\n2. Implement basic storage operations (init/open/close/put/get)\n3. Add configuration options for RocksDB\n\nExample implementation:\n```c\n// kadedb_lite.c\n#include \"kadedb_lite.h\"\n#include \"rocksdb/c.h\"\n\nstruct kadedb_lite_t {\n  rocksdb_t* db;\n  rocksdb_options_t* options;\n  rocksdb_writeoptions_t* woptions;\n  rocksdb_readoptions_t* roptions;\n};\n\nkadedb_lite_t* kadedb_lite_open(const char* path, kadedb_lite_options_t* options) {\n  kadedb_lite_t* lite = malloc(sizeof(kadedb_lite_t));\n  if (!lite) return NULL;\n  \n  lite->options = rocksdb_options_create();\n  rocksdb_options_set_create_if_missing(lite->options, 1);\n  \n  // Apply custom options if provided\n  if (options) {\n    // Apply options...\n  }\n  \n  char* err = NULL;\n  lite->db = rocksdb_open(lite->options, path, &err);\n  if (err) {\n    // Handle error\n    free(lite);\n    return NULL;\n  }\n  \n  lite->woptions = rocksdb_writeoptions_create();\n  lite->roptions = rocksdb_readoptions_create();\n  \n  return lite;\n}\n\n// Implement other functions...\n```",
        "testStrategy": "Create unit tests for the KadeDB-Lite implementation. Test basic operations like opening/closing databases, putting/getting values. Test with various configuration options. Verify error handling for invalid operations.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement RocksDB C API Integration",
            "description": "Set up the integration with RocksDB C API including initialization of the necessary structures and handling of the core RocksDB objects.",
            "dependencies": [],
            "details": "Create the basic structure for KadeDB-Lite with RocksDB integration:\n1. Define the kadedb_lite_t structure to hold RocksDB handles\n2. Implement initialization of RocksDB options, read options, and write options\n3. Set up proper memory management for RocksDB objects\n4. Create header files with appropriate function declarations\n5. Implement proper error handling for RocksDB operations",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Basic Storage Operations",
            "description": "Implement the core storage operations for KadeDB-Lite including database initialization, opening, closing, and basic key-value operations.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement the following functions:\n1. kadedb_lite_open() - Open or create a database at the specified path\n2. kadedb_lite_close() - Close the database and clean up resources\n3. kadedb_lite_put() - Store a key-value pair in the database\n4. kadedb_lite_get() - Retrieve a value by key from the database\n5. kadedb_lite_delete() - Remove a key-value pair from the database\n\nEnsure proper error handling and memory management for all operations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Configuration Options",
            "description": "Create a configuration system for KadeDB-Lite that allows customization of RocksDB behavior through options.",
            "dependencies": [
              "7.1"
            ],
            "details": "1. Define a kadedb_lite_options_t structure to hold configuration options\n2. Implement functions to create, modify, and destroy option objects\n3. Add support for common RocksDB options such as:\n   - Create if missing flag\n   - Error if exists flag\n   - Compression options\n   - Cache size configuration\n   - Write buffer size\n   - Max open files\n4. Implement option application logic in the database open function",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Unit Tests for KadeDB-Lite",
            "description": "Develop comprehensive unit tests for all KadeDB-Lite operations to ensure correct functionality.",
            "dependencies": [
              "7.2",
              "7.3"
            ],
            "details": "Create unit tests that verify:\n1. Database creation, opening, and closing\n2. Basic put/get/delete operations with various data sizes\n3. Error handling for invalid operations (e.g., getting non-existent keys)\n4. Configuration options application and effects\n5. Memory management (no leaks)\n6. Edge cases such as empty keys/values\n7. Concurrent operations if supported\n\nUse a testing framework compatible with C and ensure tests can be run automatically.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement KadeDB-Lite Query Layer",
        "description": "Add a minimal query layer to KadeDB-Lite that supports basic KadeQL operations.",
        "details": "Implement a simplified query parser and executor for KadeDB-Lite:\n\n1. Support basic SELECT and INSERT operations\n2. Map queries to RocksDB operations\n\nExample implementation:\n```c\n// kadedb_lite_query.c\n#include \"kadedb_lite.h\"\n#include \"kadedb_lite_query.h\"\n\ntypedef enum {\n  QUERY_TYPE_SELECT,\n  QUERY_TYPE_INSERT\n} query_type_t;\n\ntypedef struct {\n  query_type_t type;\n  char* table;\n  // Other query parameters\n} parsed_query_t;\n\nstatic parsed_query_t* parse_query(const char* query) {\n  // Simple parsing logic\n  // For MVP, just handle very basic queries\n}\n\nkadedb_lite_result_t* kadedb_lite_execute_query(kadedb_lite_t* db, const char* query) {\n  parsed_query_t* parsed = parse_query(query);\n  if (!parsed) return NULL;\n  \n  kadedb_lite_result_t* result = NULL;\n  \n  switch (parsed->type) {\n    case QUERY_TYPE_SELECT:\n      // Handle SELECT\n      break;\n    case QUERY_TYPE_INSERT:\n      // Handle INSERT\n      break;\n  }\n  \n  // Clean up parsed query\n  free(parsed);\n  \n  return result;\n}\n```",
        "testStrategy": "Create tests with various KadeQL queries against KadeDB-Lite. Verify that queries produce the expected results. Test error handling for invalid queries.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Query Parser for KadeDB-Lite",
            "description": "Create a minimal query parser that can parse basic SELECT and INSERT operations for KadeDB-Lite.",
            "dependencies": [],
            "details": "Implement the `parse_query()` function that can:\n1. Tokenize input query strings\n2. Identify query type (SELECT or INSERT)\n3. Extract table names and basic conditions\n4. Parse column names and values\n5. Return a properly structured `parsed_query_t` object\n\nEnsure proper error handling for malformed queries and memory management for parsed components.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Develop Query-to-RocksDB Mapping Logic",
            "description": "Implement the logic to map parsed queries to appropriate RocksDB operations.",
            "dependencies": [
              "8.1"
            ],
            "details": "Complete the `kadedb_lite_execute_query()` function to:\n1. Handle SELECT queries by translating them to RocksDB get/iterate operations\n2. Handle INSERT queries by translating them to RocksDB put operations\n3. Implement proper result set creation and management\n4. Add error handling for database operations\n5. Ensure proper memory management for query results",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Tests for Query Execution and Error Handling",
            "description": "Develop comprehensive tests for the query layer functionality and error handling.",
            "dependencies": [
              "8.1",
              "8.2"
            ],
            "details": "Create test cases that:\n1. Test basic SELECT queries with various conditions\n2. Test INSERT operations with different data types\n3. Verify error handling for malformed queries\n4. Test edge cases like empty tables or non-existent tables\n5. Verify memory management (no leaks) during query execution\n6. Test performance with larger datasets",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Sync Stubs for KadeDB-Lite",
        "description": "Add minimal synchronization stubs to KadeDB-Lite to support future sync capabilities.",
        "details": "Implement basic synchronization stubs in KadeDB-Lite:\n\n```c\n// kadedb_lite_sync.h\ntypedef struct kadedb_lite_sync_config_t {\n  const char* remote_url;\n  const char* auth_token;\n  int sync_interval_seconds;\n} kadedb_lite_sync_config_t;\n\n// Initialize sync with configuration\nint kadedb_lite_sync_init(kadedb_lite_t* db, kadedb_lite_sync_config_t* config);\n\n// Start sync process\nint kadedb_lite_sync_start(kadedb_lite_t* db);\n\n// Stop sync process\nint kadedb_lite_sync_stop(kadedb_lite_t* db);\n\n// Get sync status\nint kadedb_lite_sync_status(kadedb_lite_t* db, char** status_out);\n```\n\nImplement these functions as stubs that return success but don't actually perform synchronization. Add proper configuration options and status reporting to prepare for future implementation.",
        "testStrategy": "Create tests that verify the sync stubs can be called without errors. Test configuration parsing and status reporting. Ensure the stubs don't interfere with normal database operations.",
        "priority": "low",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Sync API Stubs",
            "description": "Create the header file and implementation for the synchronization API stubs in KadeDB-Lite.",
            "dependencies": [],
            "details": "1. Create kadedb_lite_sync.h with the specified struct and function declarations\n2. Implement kadedb_lite_sync.c with stub implementations that return success codes\n3. Add internal state tracking for sync configuration and status\n4. Ensure proper memory management for status strings\n5. Add appropriate error handling for invalid parameters\n6. Update the build system to include the new files",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Tests for Sync API Stubs",
            "description": "Develop test cases to verify the synchronization API stubs function correctly.",
            "dependencies": [
              "9.1"
            ],
            "details": "1. Create test_kadedb_lite_sync.c with test cases for all sync functions\n2. Test configuration parsing with various valid and invalid inputs\n3. Verify status reporting works correctly\n4. Test that sync operations don't interfere with normal database operations\n5. Verify memory management (no leaks when using status_out)\n6. Test error handling for edge cases (NULL parameters, etc.)\n7. Update the test build system to include the new tests",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Create Example Applications and CI Setup",
        "description": "Develop example applications demonstrating KadeDB usage and set up CI for automated testing.",
        "details": "Create example applications in `examples/` directory:\n\n1. Simple C++ application using the core API\n2. C application using the C ABI\n3. KadeDB-Lite CLI sample application\n\nExample KadeDB-Lite CLI:\n```c\n// examples/lite_cli.c\n#include \"kadedb_lite.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char** argv) {\n  if (argc < 2) {\n    printf(\"Usage: %s <db_path>\\n\", argv[0]);\n    return 1;\n  }\n  \n  kadedb_lite_t* db = kadedb_lite_open(argv[1], NULL);\n  if (!db) {\n    printf(\"Failed to open database\\n\");\n    return 1;\n  }\n  \n  char cmd[1024];\n  printf(\"KadeDB-Lite CLI\\n\");\n  \n  while (1) {\n    printf(\"> \");\n    if (!fgets(cmd, sizeof(cmd), stdin)) break;\n    \n    // Remove newline\n    cmd[strcspn(cmd, \"\\n\")] = 0;\n    \n    if (strcmp(cmd, \"exit\") == 0 || strcmp(cmd, \"quit\") == 0) {\n      break;\n    }\n    \n    // Execute query\n    kadedb_lite_result_t* result = kadedb_lite_execute_query(db, cmd);\n    if (result) {\n      // Display result\n      kadedb_lite_result_free(result);\n    }\n  }\n  \n  kadedb_lite_close(db);\n  return 0;\n}\n```\n\nSet up CI configuration for automated testing:\n1. GitHub Actions or similar CI system\n2. Build jobs for different platforms\n3. Unit test execution\n4. Example application builds",
        "testStrategy": "Manually test the example applications to ensure they work as expected. Verify that the CI configuration correctly builds and tests the project on all supported platforms.",
        "priority": "medium",
        "dependencies": [
          6,
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement C++ Example Application",
            "description": "Create a simple C++ application demonstrating the usage of KadeDB core API",
            "dependencies": [],
            "details": "Develop a C++ example in `examples/cpp_example/` that demonstrates:\n- Database creation and opening\n- Basic CRUD operations using the core API\n- Query execution with KadeQL\n- Error handling\n\nThe example should be well-commented to serve as a tutorial for new users. Include a CMakeLists.txt file to build the example and document how to run it in a README.md file.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement C Example Application",
            "description": "Create a C application demonstrating the usage of KadeDB through the C ABI",
            "dependencies": [
              "10.1"
            ],
            "details": "Develop a C example in `examples/c_example/` that demonstrates:\n- Database initialization using the C ABI\n- Basic CRUD operations through the C interface\n- Memory management with proper cleanup\n- Error handling\n\nEnsure the example is well-commented and includes a Makefile or CMakeLists.txt for building. Document usage instructions in a README.md file.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Complete KadeDB-Lite CLI Sample Application",
            "description": "Finish implementing the KadeDB-Lite CLI sample application based on the provided skeleton",
            "dependencies": [
              "10.1",
              "10.2"
            ],
            "details": "Complete the implementation of the KadeDB-Lite CLI in `examples/lite_cli/`:\n- Implement the result display functionality\n- Add command history and basic line editing\n- Support for help commands and documentation\n- Add basic data import/export commands\n\nExtend the provided skeleton code to create a fully functional CLI. Include a CMakeLists.txt file and documentation on how to build and use the CLI.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Setup CI Configuration",
            "description": "Configure CI for automated testing and building across multiple platforms",
            "dependencies": [
              "10.1",
              "10.2",
              "10.3"
            ],
            "details": "Set up GitHub Actions or similar CI system with the following jobs:\n- Linux build and test (Ubuntu latest)\n- macOS build and test\n- Windows build and test\n- Code coverage reporting\n- Example application builds\n\nEnsure the CI configuration includes:\n- Caching of dependencies to speed up builds\n- Matrix builds for different compiler versions\n- Automated unit test execution\n- Building and testing all example applications\n- Proper reporting of test results",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-21T06:20:26.232Z",
      "updated": "2025-08-23T01:07:32Z",
      "description": "Tasks for master context"
    }
  }
}
